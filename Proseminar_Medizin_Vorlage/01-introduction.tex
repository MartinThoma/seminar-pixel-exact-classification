%!TEX root = vorlage.tex
% Marvin Teichmann and Martin Thoma
\section{Introduction}\label{sec:introduction}
Semantic segmentation is the task of clustering parts of images together which
belong to the same object. This type of algorithm has several use-cases such as
detecting objects in robotics (TODO: cite), detecting street signs in
self-driving car software (TODO: cite), detecting tumors in medicine (TODO:
cite), detecting medical instruments in operations and distingushing them from
tissue (TODO: cite), colon crypts segmentation~\cite{cohen2015memory}. In
contrast, non-semantic segmentation only clusters pixels together (TODO:
improve wording). Hence the task of non-semantic segmentation is not
well-defined, as many different segmentations might be acceptable.

% Pixelwise segmentation is an imporant sub-task of many applications and can
% be applied to support even more applications: Understanding images (TODO:
% Cite paper google automatically labeling images), object detection (TODO:
% Cite a paper probably by Asfour), street detection (TODO: Cite), face
% detection (TODO: cite) and medical instrument detection (TODO: cite) are only
% a couple of the possible applications.

% In many applications speed and accuracy is crucial. In this paper, we
% summarize the current state of semantic segmentation.


Taking a step back, the task of semantic segmentation can be grouped in several
categories:

\begin{itemize}
    \item \textbf{By possible classes}: Are the classes which should be distinguised
          known at the time when the algorithm is developed / trained or might
          there occur several objects which were never seen before?
          \begin{itemize}
              \item Fixed-class: All classes are known at training time.
                    \begin{itemize}
                        \item Binary: street/no street.
                    \end{itemize}
              \item Open-class: There might be completely new classes
          \end{itemize}
    \item \textbf{By class affiliation of pixels}:
          \begin{itemize}
              \item Single class affiliation: Every pixel belongs to exactly one class. There might
                    be probabilities, but a pixel cannot belong with a 100\%
                    probability to two classes.
              \item Multiple class affiliation: A single pixel might belong to
                    multiple classes. An example is a glass on a table: One
                    knows that the glass is there and it is possible to see the
                    table below / behind. Another example is hair. Mattening
                    methods produce maps which reflect this property for hair.\cite{levin2008spectral}
          \end{itemize}
    \item \textbf{By input data}:
          \begin{itemize}
              \item greyscale / colored / with depth (RGB-D)
              \item single image (NOTE: we write about this) / time series (NOTE: only mention it)
              \item pixels / voxels \cite{wolz2012multi}
          \end{itemize}
    \item \textbf{Operation state}:
          \begin{itemize}
              \item completely automatically <-- we write about this type
              \item interactive (e.g. user clicks on background or user makes a
                    coarse segmentation and automatically refinement) as
                    described in
                    \cite{protiere2007interactive,rother2004grabcut}.
              \item active as in
                    \cite{schiebener2011segmentation,schiebener2012discovery} or
                    passive, where the received image cannot be influenced
          \end{itemize}
\end{itemize}

This paper is organized as follows: We begin by giving an overview over quality
measures and datasets which are used for semantic segmentation. A summary of
the most important traditional segmentation algorithm and their characteristics
follows, as well as a similar summary of recently published semantic
segmentation algorithms which are based on neural networks. The next section
informes the reader about typical problematic cases for segmentation
algorithms. As speed is one of the hard requirements in practical applications,
we outline some of the actions that can be applied to improve the speed of
segmentation algorithms. Finally, we mention some of the publications which
examine automatic image enhancement.
